{"version":3,"sources":["../src/index.js"],"names":["protocol","require","prop","Object","prototype","hasOwnProperty","call","module","exports","configurable","enumerable","get","makeAsync","fn","resolve","apply","parseMessage","message","error","defaultOnMessage","type","method","noop","nextRequestId","Peer","onMessage","_handle","_deferreds","_getDeferred","id","deferred","exec","data","results","all","then","result","undefined","push","reject","code","catch","response","failPendingRequests","reason","deferreds","request","params","requestId","notify","notification","pipe","writable","listeners","write","end","clean","listener","event","removeListener","on","emit","String"],"mappings":"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","file":"index.js","sourcesContent":["import { EventEmitter } from 'events'\nimport {\n  forEach,\n  isArray,\n  map,\n} from 'lodash'\nimport {\n  format,\n  JsonRpcError,\n  MethodNotFound,\n  parse,\n} from 'json-rpc-protocol'\n\n// ===================================================================\n\n// Give access to low level interface.\n// export * from 'json-rpc-protocol'\n// FIXME: work around for https://fabricator.babeljs.io/T2877\n{\n  const protocol = require('json-rpc-protocol')\n  for (const prop in protocol) {\n    if (prop !== 'default' && Object.prototype.hasOwnProperty.call(protocol, prop)) {\n      Object.defineProperty(module.exports, prop, {\n        configurable: true,\n        enumerable: true,\n        get: () => protocol[prop],\n      })\n    }\n  }\n}\n\n// ===================================================================\n\nfunction makeAsync (fn) {\n  return function () {\n    return new Promise(resolve => resolve(fn.apply(this, arguments)))\n  }\n}\n\nconst parseMessage = message => {\n  try {\n    return parse(message)\n  } catch (error) {\n    throw format.error(null, error)\n  }\n}\n\n// Default onMessage implementation:\n//\n// - ignores notifications\n// - throw MethodNotFound for all requests\nfunction defaultOnMessage (message) {\n  if (message.type === 'request') {\n    throw new MethodNotFound(message.method)\n  }\n}\n\nfunction noop () {}\n\n// Starts the autoincrement id with the JavaScript minimal safe integer to have\n// more room before running out of integers (it's very far fetched but a very\n// long running process with a LOT of messages could run out).\nlet nextRequestId = -9007199254740991\n\n// ===================================================================\n\nexport default class Peer extends EventEmitter {\n  constructor (onMessage = defaultOnMessage) {\n    super()\n\n    this._handle = makeAsync(onMessage)\n    this._deferreds = Object.create(null)\n  }\n\n  _getDeferred (id) {\n    const deferred = this._deferreds[id]\n    delete this._deferreds[id]\n    return deferred\n  }\n\n  async exec (message, data) {\n    message = parseMessage(message)\n\n    if (isArray(message)) {\n      const results = []\n\n      // Only returns non empty results.\n      await Promise.all(map(message, message => {\n        return this.exec(message, data).then(result => {\n          if (result !== undefined) {\n            results.push(result)\n          }\n        })\n      }))\n\n      return results\n    }\n\n    const {type} = message\n\n    if (type === 'error') {\n      const {id} = message\n\n      // Some errors do not have an identifier, simply discard them.\n      if (id === null) {\n        return\n      }\n\n      const {error} = message\n      this._getDeferred(id).reject(\n        // TODO: it would be great if we could return an error with of\n        // a more specific type (and custom types with registration).\n        new JsonRpcError(error.message, error.code, error.data)\n      )\n    } else if (type === 'response') {\n      this._getDeferred(message.id).resolve(message.result)\n    } else if (type === 'notification') {\n      this._handle(message, data).catch(noop)\n    } else {\n      return this._handle(message, data).then(\n        (result) => format.response(message.id, result === undefined ? null : result),\n        (error) => format.error(\n          message.id,\n\n          // If the method name is not defined, default to the method passed\n          // in the request.\n          (error instanceof MethodNotFound && !error.data)\n            ? new MethodNotFound(message.method)\n            : error\n        )\n      )\n    }\n  }\n\n  // Fails all pending requests.\n  failPendingRequests (reason) {\n    const {_deferreds: deferreds} = this\n\n    forEach(deferreds, ({reject}, id) => {\n      reject(reason)\n      delete deferreds[id]\n    })\n  }\n\n  /**\n   * This function should be called to send a request to the other end.\n   *\n   * TODO: handle multi-requests.\n   */\n  request (method, params) {\n    return new Promise((resolve, reject) => {\n      const requestId = nextRequestId++\n\n      this.push(format.request(requestId, method, params))\n\n      this._deferreds[requestId] = {resolve, reject}\n    })\n  }\n\n  /**\n   * This function should be called to send a notification to the other end.\n   *\n   * TODO: handle multi-notifications.\n   */\n  async notify (method, params) {\n    this.push(format.notification(method, params))\n  }\n\n  // minimal stream interface\n\n  pipe (writable) {\n    const listeners = {\n      data: data => writable.write(data),\n      end: () => {\n        writable.end()\n        clean()\n      },\n    }\n\n    const clean = () => forEach(listeners, (listener, event) => {\n      this.removeListener(event, listener)\n    })\n    forEach(listeners, (listener, event) => {\n      this.on(event, listener)\n    })\n\n    return writable\n  }\n\n  push (data) {\n    return data === null\n      ? this.emit('end')\n      : this.emit('data', data)\n  }\n\n  write (message) {\n    this.exec(String(message)).then(\n      response => {\n        if (response !== undefined) {\n          this.push(response)\n        }\n      },\n      error => {\n        this.emit('error', error)\n      }\n    )\n  }\n}\n"]}